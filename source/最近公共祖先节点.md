---
title: 二叉树的最近公共祖先节点
date: 2020-11-22 16:38
tags: 
- 树
- 算法
---

>题目地址:https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/
*又是一道很灵活的树题目*
思路: 判断每一个节点的左右子树中是否存在p/q节点,用lson和rson来表示左右子树的结果。同时当前节点也可以作为祖先节点，所以需要判断一个节点是不是公共祖先节点的条件如下：
lson && rson || ( (lson || rson) && (cur === p || cur === q))，就是两种情况。
1. 左子树中有p/q节点中的一个，右子树有p/q节点中的另一个
2. 左子树有p/q节点中的一个，当前节点就是p/q节点中的另一个 
3. 右子树有p/q节点中的一个，当前节点就是p/q节点中的另一个 

同时题目要求得到的是最近的公共祖先节点，由于这个算法设置的是，左右子树中的结果分别存储在lson和rson当中，所以设想一下，最近公共祖先节点的父节点，它的左子树或者右子树肯定是已经包含了p节点和q节点，所以lson和rson肯定只能有一个满足条件，导致这个节点不可能满足条件。**算法真是个奇妙的东西**

代码:
```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    let res = null;
    function dfs(cur) {
        if (cur === null) {
            return ;
        }
        let lson = dfs(cur.left),
            rson = dfs(cur.right);
        if (lson && rson || (cur === p || cur === q) && (lson || rson)) {
            res = cur;
        }
        return lson || rson || (cur === p) || (cur === q);
    }
    dfs(root);
    return res;
};
```
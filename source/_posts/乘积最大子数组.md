---
title: 乘积最大子数组
date: 2020-11-15 13:26
tags: 
- 算法
---

超时思路：定义一个二位的dp数组。数组中dp[i][j]就表示nums数组当中，下标j到i的最大数值。 
使用一个双层循环，
* 外层循环变量i：以nums[i]结尾的子数组的最大乘积。  
* 内层循环j：从0到i-1之间，每一个数字连续乘到nums[i]的乘积。
通过双层循环的方式把nums[i]之前的每一个数值连续乘到nums[i]，然后使用max数组求得从哪一个数字乘到nums[i]的值是最大的。
```
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
    let dp = [],
        max = nums[0]; //j到i之间的最大值
        
    for (let i = 1; i < nums.length; i++) {
        dp[i] = [];
        dp[i][i] = nums[i];
        max = Math.max(dp[i][i], max);
        for (let j = i-1; j >= 0; j--) {
            dp[i][j] = dp[i][j+1] * nums[j];
            max = Math.max(dp[i][j], max);
        }
    }
    return max;
};
```
这个代码可以通过大部分的实例，但是很显然，复杂度太高了，所以超时了。

2. 成功思路：
踩坑：因为乘积法则的特殊原因，如果单纯通过前面的数值的最大值(dp[i-1])，乘以当前值来算出当前最大值(dp[i])是一种鼠目寸光的做法。举个例子，[5,6,−3,4,−3],单纯通过dp[i] = Math.max(dp[i-1], max)的话，计算到4的时候，最大值是4，然后-3乘以4得出以3结尾的数组的最大值是-3。显然是错误的，这是因为忽略了乘法当中负负得正的规则。正确的答案是5*6*（-3）*4*（-3），按照前面的做法，这个最大值，延续到第一个（-3）的时候就已经断了。

所以正确的做法是：使用两个数组来记录状态值。一个叫做minDp，一个叫做maxDp。通过名字就知道是什么意思，前者维护最小值，后者维护最大值。这样就可以把负负得正的法则给考虑进去，每一次都记录了最小值，**比如在计算最大值的时候，当前值是一个负数，乘以最小值(minDp[i-1])刚好是负负得正变成一个更大的值。**最小值也是同理。
*需要注意的是，在比较的过程中还要比较nums[i]。如果没有把nums[i]考虑进去，比如说[0, 2]，在计算到2的时候，minDp[0]和maxDp[0]都是0，返回的最大值结果就是0----max(maxDp[0]*nums[1], minDp[0]*nums[1])，但是正确的最大值应该是2。*

正确代码：
```
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
    let maxDp = [],
        minDp = [],
        res = nums[0];
    
    maxDp[0] = minDp[0] = nums[0];
    for (let i = 1, len = nums.length; i < len; i++) {
        minDp[i] = Math.min(maxDp[i-1]*nums[i], minDp[i-1]*nums[i], nums[i]);
        maxDp[i] = Math.max(maxDp[i-1]*nums[i], minDp[i-1]*nums[i], nums[i]);
        res = Math.max(res, maxDp[i]);
    }

    return res;
};
```


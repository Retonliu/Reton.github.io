---
title: 接雨水
date: 2020-12-11 16:13
tags:
- 双指针
- 数组
- 算法
---

>题目地址：https://leetcode-cn.com/problems/trapping-rain-water/

思路：
1. 通过暴力法来求解，要求出每一个圆柱可以存的雨水，就要求出它左边的最高圆柱以及它右边的最高圆柱，然后由两个最高圆柱中比较小的那一个来决定这个柱子可以存多少水。按照这种方法，对于每一个圆柱都要求出它的左边最大值和右边最大值，时间复杂度为O（n^2），有点高了。

2. 从暴力法得到启发，每一次都要对一个圆柱求出它左右两边的最大值，这个是导致了时间复杂度过高的重要原因。仔细想想，对于每一个圆柱它的左右两边最大值其实是动态变化的。**对左边最大值来说，越往左，它的左边最大值的可选范围就更大，而这个范围是随着下标逐渐往左来扩大的，对右边最大值来说也是同理。**所以就想出了，取代掉暴力法内部每次都要循环查找最大值分方法，通过随着下标的移动，每次都维护左边最大值就可以了，同时为了维护右边的最大值，再定义一个右指针，至此双指针的方法就出来了。总的思路就是，根据左右指针的移动来维护对于当前柱子的左右最大值。**由于计算柱子的容量是取决于左右最大值中比较小的那一个，所以每一次计算的时候，如果左边最大值比右边最大值还要小，那就计算左指针所在的那个柱子，右边的先别计算，因为对于右边的来说，左边的最大值是不确定的，所以如果直接计算右边的容量，那么可能会是白算，因为左边柱子可能都是小于右边最大值的，即雨水全部流走没有留住。直接leftMax-height[left]就得出容量，计算完之后，左指针右移动，注意这里有个要点就是左指针当前所在柱子的高度可能大于左边最大值，所以每一次计算的时候，要首先维护左边最大值；右边也是同理，右边最大值比左边最大值小的时候，那就计算右边的容量，因为此时对于左边来说，右边最大值是不确定的，右边最大值可能会找不到大于当前左边最大值的，这样就会导致左边储存的水会流走。

代码:
```
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
    let len = height.length,
        left = 0,
        right = len - 1,
        leftMax = 0,
        rightMax = 0,
        res = 0;
    
    while (left <= right) {
        if (leftMax < rightMax) {
            leftMax = Math.max(leftMax, height[left]);
            res += leftMax - height[left];
            left++;
        } else {
            rightMax = Math.max(rightMax, height[right]);
            res += rightMax - height[right];
            right--;
        }
    }
    return res;
};
```
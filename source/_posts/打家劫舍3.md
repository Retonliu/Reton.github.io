---
title: 排序链表
date: 2020-12-15 15:15
tags:
- 动态规划
- 树
- 算法
---

思路：联系做过的类似题目，知道这是一道动态规划的题目，难点在于，以前动态规划使用的是数组，所以建立的是数组的下标于数组的值的关系。但是树不一样，不能使用下标来建立联系，但是每个树的节点都是一个引用类型的值，所以可以使用map来存储。  对于每户人家，有两种可能状态，第一种是没有被打劫，第二种是被打劫了。 所以使用fMap来表示这一户被打劫了，gMap来表示这一户没有被打劫，所以小偷得到的最大的钱，就是以根节点为键fMap取得的值和gMap取得的值的最大值。 老规矩，首先是定义Map的键和值的定义：
1. 键是节点，值是选/不选这个节点所能取得的最大值
2. 状态转移方程： 选择当前节点的话，那么状态就只能由左右节点均不选择的值推导过来
                不选择当前节点的话，那么状态就可以由左节点选/不选，以及右节点选/不选推导过来，**这里很容易想成是层次遍历，以为当前节点不选的话，两个子节点都必须选，其实是不一定的，也可能出现当前节点不选择，选择了左节点，而右节点不选择的时候，值是最大的。比如[4, 10, 1, 0, null, null, 12]**

代码：
```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var rob = function(root) {
    let fMap = new Map(),
        gMap = new Map();
    function dfs(cur) {
        if (cur === null) {
            return ;
        }
        dfs(cur.left);
        dfs(cur.right);
        fMap.set(cur, cur.val + (gMap.get(cur.left) || 0) + (gMap.get(cur.right) || 0));
        gMap.set(cur, Math.max((fMap.get(cur.left) || 0), (gMap.get(cur.left)) || 0) + Math.max((fMap.get(cur.right) || 0), (gMap.get(cur.right) || 0)));
    }
    dfs(root);
    return Math.max(fMap.get(root) || 0, gMap.get(root) || 0);
};
```
---
title: 分割等和子集
date: 2020-11-18 19:37
tags:
- 算法
---

>题目地址：https://leetcode-cn.com/problems/partition-equal-subset-sum/submissions/

思路：把这道题抽象为是一道背包问题的变体。[讲解0-1背包问题灰常好的一个博客](https://www.jianshu.com/p/a66d5ce49df5)。这道题要求两个和相同的子集，可以理解为是求能不能把一个容量为sum/2的背包刚好填满（sum是nums数组种所有物品的和）。动态规划采用背包问题的方式，不过状态和方程不同：
状态： dp[i][j]表示容量为j的背包面对前i种物品，能不能刚好装满。
转移方程：每次如果当前背包容量放得下物品，就判断如果放进去了这个物品之后，剩下的那个容量的子状态是不是为true，或者前i-1个物品就可不可以满足刚好装满背包的要求，即dp[i][j]取决于dp[i-1][j-nums[i]]或者dp[i-1][j]。   当然如果背包容量如果不足以放下当前物品，那就只能取决于前i-1个物品的时候的状态了即dp[i][j]取决于dp[i-1][j]。

高复杂度代码：
```
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function(nums) {
    let sum = 0;
    const len = nums.length;
    for (const num of nums) {
        sum += num;
    }
    if (sum % 2 !== 0 || len < 2) {
        return false;
    }
    sum /= 2;

    const dp = new Array(len).fill(false).map(v => new Array(sum + 1, false));
    for (let i = 0; i < len; i++) {
        dp[i][0] = true;
    }
    for (let i = 1; i < len; i++) {
        for (let j = 1; j <= sum; j++) { //j表示j+1的重量
            if (j >= nums[i]) {
                dp[i][j] = dp[i-1][j-nums[i]] | dp[i-1][j];
            } else {
                dp[i][j] = dp[i-1][j];
            }
        }
    }
    return dp[len-1][sum];
};
```
这是没有压缩空间复杂度的做法，所以复杂度比较高。
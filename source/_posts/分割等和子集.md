---
title: 分割等和子集
date: 2020-11-18 19:37
tags:
- 算法
---

>题目地址：https://leetcode-cn.com/problems/partition-equal-subset-sum/submissions/

思路：把这道题抽象为是一道背包问题的变体。[讲解0-1背包问题灰常好的一个博客](https://www.jianshu.com/p/a66d5ce49df5)。这道题要求两个和相同的子集，可以理解为是求能不能把一个容量为sum/2的背包刚好填满（sum是nums数组种所有物品的和）。动态规划采用背包问题的方式，不过状态和方程不同：
状态： dp[i][j]表示容量为j的背包面对前i种物品，能不能刚好装满。
转移方程：每次如果当前背包容量放得下物品，就判断如果放进去了这个物品之后，剩下的那个容量的子状态是不是为true，或者前i-1个物品就可不可以满足刚好装满背包的要求，即dp[i][j]取决于dp[i-1][j-nums[i]]或者dp[i-1][j]。   当然如果背包容量如果不足以放下当前物品，那就只能取决于前i-1个物品的时候的状态了即dp[i][j]取决于dp[i-1][j]。

高复杂度代码：
```
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function(nums) {
    let sum = 0;
    const len = nums.length;
    for (const num of nums) {
        sum += num;
    }
    if (sum % 2 !== 0 || len < 2) {
        return false;
    }
    sum /= 2;

    const dp = new Array(len).fill(false).map(v => new Array(sum + 1, false));
    for (let i = 0; i < len; i++) {
        dp[i][0] = true;
    }
    for (let i = 1; i < len; i++) {
        for (let j = 1; j <= sum; j++) { //j表示j+1的重量
            if (j >= nums[i]) {
                dp[i][j] = dp[i-1][j-nums[i]] | dp[i-1][j];
            } else {
                dp[i][j] = dp[i-1][j];
            }
        }
    }
    return dp[len-1][sum];
};
```
时间超过百分之六，空间超过百分之十一，我直接好家伙。
这是没有压缩空间复杂度的做法，所以复杂度比较高。

>压缩之后的博客讲解：https://www.cnblogs.com/kkbill/p/12081172.html

这里补充一下我看了之后对于压缩的理解。由于在代码当中，每次更新dp[i][j]用到的数据都是上一层的数据，也就是在决定前i个物品的状态的时候，需要用到的状态都是前i-1个物品的状态。所以可以把二位数组变为一维数组，每一轮外循环就刷新一次dp[i]即从前i个物品变为前i-1个物品，总共刷新len次（即物品总数）。
1. 每一轮外循环，dp[i]计算的时候用到的值就是上一轮dp[i]的值，比如说现在要计算dp[4]那么在当前循环当中，没有赋值之间，dp[4]表示的值就是上一轮dp的值，也即原本dp[i-1][j]之于dp[i][j]的意义。
2. 而之所以要从后往前遍历，是因为每一次的遍历用到的值可能会是小背包的值，比如dp[4]可能会用到dp[3]的值，而如果是从前往后遍历的话，此时dp[3]的值已经是新一轮的值了，即由原本dp[i-1][j-nums[i]]变为dp[i][j-nums[i]]了，而我们要用的是dp[i-1][j-nums[i]]。所以应该从后往前遍历，因为前面的值不需要用到后面的值。
3. 内循环的退出循环的条件是，j >= nums[i]，这样可以减少不必要的遍历。因为根据一维dp的状态转移方程，每一次更不更新取决于j是否大于nums[i]，如果j小于nums[i]，那么dp[i]继续等于上一轮的值，即原本的dp[i][j] = dp[i-1][j]，而在一维当中，不更新的时候，dp[i]就是当前dp[i]上一轮的值。

所以更新后的代码如下:
```
/**
 * @param {number[]} nums
 * @return {boolean}
 */

 //物品的价值也是物品的重量
var canPartition = function(nums) {
    let sum = 0;
    const len = nums.length;
    for (const num of nums) {
        sum += num;
    }
    if (sum % 2 !== 0 || len < 2) {
        return false;
    }
    sum /= 2;
    let dp = new Array(sum+1).fill(false);
    dp[0] = true;
    for (let i = 0; i < len; i++) { //表示多少层，即多少个物品
        for (let j = sum; j >= nums[i]; j--) { //重量
            dp[j] = dp[j] || dp[j-nums[i]];
        }
    }
    return dp[sum];
};
```
空间复杂度由原来的O(sum*len)变为现在的O(sum)
---
title: 排序链表
date: 2020-12-14 15:05
tags:
- 链表
- 算法
---

>题目地址：https://leetcode-cn.com/problems/insertion-sort-list
思路：在原链表的基础上使用插入排序的方法排序链表。总共需要4个比较重要的节点：
1. 因为第一个头节点在后续的排序中也可能是要移动的，所以创建一个哑节点dummpyNode来作为头节点的上一个节点，方便进行排序
2. 因为是在原链表的基础上修改的，所以需要一个last指针来指示前面已经排序好的链表部分
3. 每一次对last指针后面一个的节点拆出来进行排序，所以再使用一个cur指针来指向每一次需要拿出来排序的节点。
4. 每一次都要从已经排序好的链表开始查找cur节点要插入的位置，所以需要一个tmp节点每次都指向哑节点来作为查询的起点

代码：
```
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var insertionSortList = function(head) {
    if (!head) {
        return head;
    }
    let dummpyNode = new ListNode(0);
    dummpyNode.next = head;
    let cur = head.next,
        last = dummpyNode.next; //有序链表的最后一个节点

    while (cur) {
        let tmp = dummpyNode.next,
            pre = dummpyNode;
        while (tmp.val < cur.val && tmp !== cur) {
            pre = tmp;
            tmp = tmp.next;
        }
        if (tmp === cur) {
            //如果是因为移动到了最后一个有序节点退出的话，特殊处理以方便移动last
            last = last.next;
            cur = cur.next;
        } else {
            last.next = cur.next;
            pre.next = cur;
            cur.next = tmp;
            cur = last.next;
            //重点：进行last的维护
        }
    }
    return dummpyNode.next;
};
```
这个代码还是比较慢，经过后续进行改装后代码如下:
```
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var insertionSortList = function(head) {
    if (!head) {
        return head;
    }
    let dummpyNode = new ListNode(0);
    dummpyNode.next = head;
    let cur = head.next,
        last = dummpyNode.next; //有序链表的最后一个节点

    while (cur) {
        if (cur.val > last.val) {
            last = last.next;
        } else {
            let tmp = dummpyNode;
            while (tmp.next.val < cur.val) {
                tmp = tmp.next;
            }
            
            last.next = cur.next;
            
            cur.next = tmp.next;
            tmp.next = cur;
        }
        cur = last.next;
    }
    return dummpyNode.next;
};
```
针对cur.val已经大于last.val的情况就不需要再进行查询了，直接下一个，减少了不必要的移动。然后省去了pre指针，转而使用了tmp来代替原本pre指针的功能，用tmp.next来代替原本tmp的功能，省略了几次节点赋值以及节省了一点点的空间。  **这个tmp.next的使用非常灵活，要mark下来**
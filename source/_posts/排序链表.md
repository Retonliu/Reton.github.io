---
title: 排序链表
date: 2020-12-15 15:15
tags:
- 链表
- 算法
---

>题目地址：https://leetcode-cn.com/problems/sort-list/

思路：排序链表的方法有上次用过的插入排序的算法，但是这道题的要求是使用时间复杂度为O(nlogn)以及空间复杂度为O(1)的算法，所以插入排序显然是不满足条件的。看到logn就想到了二分法，联系到这是一道排序的算法，所以比较熟悉的有快速排序和归并排序算法，堆排序。而作为一道链表的题目，归并排序显然是比较适合的。 
做法就是使用递归来实现归并排序的做法。重要的点：
1. 找出链表的中点来cut。 **这里使用快慢指针来找到链表的中点，快指针每一次走两个格子，当快指针到达null的时候说明slow到达了中点左边的节点（偶数）或者中间的节点（奇数）。注意这里slow指针是从head开始，而fast是从head.next指针开始这样才能满足找到中间节点的要求。**
2. 进行合并，合并的话，数组的归并排序是再建立一个空数组，然后每一次把满足条件的两个数组中的元素加进来，但是这样空间复杂度就要多个n了，所以是不满足条件的。因为这是一道链表的题目，所以可以通过使用一个额外的哑指针来指向排序merge后的链表。 

代码：
```
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var sortList = function(head) {
    if (head === null || head.next === null) {
        //递归终止条件
        return head;
    }

    let fast = head.next,
        slow = head;

    //忍术：cut
    while (fast !== null && fast.next !== null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    let tmp = slow.next; // 中间节点
    slow.next = null;

    //忍术：分治
    let left = sortList(head)
    let right = sortList(tmp);
    let res = merge(left, right);

    return res;
};

function merge(left, right) {
    let dummpyNode = new ListNode(0); //记录头节点
    let res = dummpyNode;
    while (left !== null && right !== null) {
        if (left.val < right.val) {
            res.next = left;
            left = left.next;
        } else {
            res.next = right;
            right = right.next;
        }
        res = res.next;
    }
    res.next = left === null ? right : left; // 连接上剩下的最后部分
    return dummpyNode.next;
}
```
时间复杂度是归并排序的复杂度：O(nlogn)，虽然取消了临时创建的数组，但是由于递归的特性使得空间复杂度仍然为O（logn），明天再进行改进
*上一次的topk以及这一次的sortList都用到了排序，得找个时间去把几个重要的排序算法温习一遍。*
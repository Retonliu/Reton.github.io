---
title: 尾递归优化的实现
date: 2020-10-25 21:28
tags:
- es6
- javascript
- 前端
---

由于非严格模式下无法直接使用尾递归优化，所以需要自己手动实现。
实现函数：
```
function tco(f) {
    var value;
    var active = false;
    var accumulated = [];

    return function accumulator() {
        accumulated.push(arguments);
        if (!active) {
            active = true;
            while (accumulated.length) {
                value = f.apply(this, accumulated.shift());
            }
            active = false;
            return value;
        }
    };
}

var sum = tco(function(x, y) {
    if (y > 0) {
        return sum(x + 1, y + 1);
    } else {
        return x;
    }
});

sum(1, 100000);
```
1. 首先是调用tco函数赋值给sum，此时得到的是return的函数accumulator,
2. 然后sum(1, 100000)，调用accumulator，第一个传进去的参数是1和100000
3. **调用accumulator，首先是将闭包里面的active由false改为true**。然后在while循环的第一次执行的时候，f.apply第一次调用传进去的匿名函数function(x, y)，传入的参数是accumulated数组的第一个元素(1, 100000)，同时shift方法将其删除
4. 调用匿名函数function(x, y)，第一个条件判断执行return sum(x + 1, y - 1), 于是重复第一个步骤，但是有一个很大的不同，闭包里面的active此时已经是true了，**所以重复的过程并不会执行accumulator的if里面的代码块,执行到将此时的参数(x+1, y-1)压入accumulated数组即结束。然后返回undefined。阻止了递归的运行。**
5. 由于上一步将参数压进去accumulated，所以while可以继续进行下去。

**总结起来就是，tco函数返回一个函数accumulator，accumulator第一次执行的时候会执行到赋值value语句的那一块，然后由于f.apply的执行，每一次都进入accumulator只执行第一条语句（将arguments压进去accumulated数组），在这个过程中，不断的调用匿名函数function(x, y),同时传进来的参数不多进行x + 1和y - 1,执行到返回x之后彻底结束，此时y减少到0，x增加到100001。**
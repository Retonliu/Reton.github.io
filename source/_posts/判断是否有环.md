---
title: 环形链表
date: 2020-11-12 22:22
tags:
- 算法
---
>题目地址：https://leetcode-cn.com/problems/linked-list-cycle/

第一种思路：建立一个用来存储遍历过的节点的数组。在循环当中，每次遍历一个节点，就判断这个节点是否跟数组中的节点有相同的，有就说明是一个环。每次都把节点放进数组中。

第二种思路：使用快慢两个指针来分别记录节点。快指针每次移动两格，慢指针每次只移动一格。如果这是一个环的话，那么快指针会在某个时刻跟慢指针重合。如果不是那么快指针就会直接跑出去，直接return false，判断无环。

第一种思路的代码：
```
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    let cur = head,
        record = [];
    while (cur !== null) {
        for (let tmp of record) {
            //console.log(`当前num：${num},当前val：${val}`);
            if (tmp === cur) {
                return true;
            }
        }
        record.push(cur);
        cur = cur.next;
    }
    return false;
};
```
这个算法写的挺糟糕的，无论是从时间上还是空间上。

第二种思路的代码：
```

  //Definition for singly-linked list.
  function ListNode(val) {
      this.val = val;
      this.next = null;
  }


/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    if (head === null || head.next === null) {
        //防止下面初始化的时候报错
        return false;
    }
    let slow = head,
        fast = head.next;
    while (slow !== fast) {
        if (fast === null || fast.next === null) {
            //没有环直接跑出去了
            return false;
        }
        fast = fast.next.next;
        slow = slow.next;
    }
    return true;
}
```
这个算法只使用了两个指针，所以符合题目的进阶要求，只使用O(1)的额外空间。
---
title: 软件工程复习笔记
date: 2021-01-14 09:12
tags: 软件工程
---

# 计算机软件（了解）
## 软件的基本概念 （考————————————点）
计算机系统中的**程 序**及其**文档** 
## 软件的特点
+ 软件是**逻辑**实体，其开发**成本和进度难以准确地 估算** 
+ 软件**没有明显的制造过程**，一旦开发成功，只需**复制** 即可，但其**维护**的工作**量大** 
+ 软件**没有**硬件**磨损**和 **老化**问题
+ 对计算机**硬件**有**依赖**性 
+ **尚未**完全实现**自动化** 
+ **成本**相当**昂贵**
+ **社会**因素
## 软件的分类
+ 系统软件，最靠近硬件的。如操作系统
+ 支撑软件，支持软件开发维护的软件。如数据库管理系统
+ 应用软件，特定领域专用软件，如嵌入式应用软件
# 软件工程（掌握）
## 软件工程的基本概念（重点）（考————————————点）
将系统化的、严格约束的、 可量化的方法应用于软件的开发、运行和维护，即 将工程化应用于软件
+ 系统化：软件开发过程要形成体系。
+ 有约束：每个阶段的工作要有既定的规则。
+ 可量化：对每个阶段的工作，事先计划与事后评价应该[在一定程度上的]有可量化的标准。
+ 全过程：软件开发时不仅要考虑当前，而且还要考虑日后的维护。
## 软件生存周期 （考————————————点）
1. 项目规划
2. 需求分析
3. 软件设计
4. 编码实现
5. 软件测试
6. 交付/发布
7. [实施]
8. 运行与维护
9. 弃用
其中
+ 从整个软件生命周期的角度，分为前期规划、软件开发、运行维护等3大阶段。
+ 软件开发分为需求分析、设计、实现与测试等4个阶段。
# 软件过程（理解）
## 概念
软件开发的步骤
## 主要模型的原理与特点
### 瀑布模型
![](pubu.png)
与经典的软件生命周期一致
特点：
1. 文挡驱动，比较正规，同时也比较繁琐；
2. 过程清晰，容易推行；
3. 纠正前期工作错误的代价昂贵
缺点:
1. 不容易一开始就确切掌握软件需求
2. 如果第一点没做好,问题要到开发完成并交付用户之后才暴露
3. 出现问题要大量推翻之前的工作成果,代价巨大
### 原型模型
![](yuanxing.png)
概念: 能够反映预期系统部分特征的一个可执行版本  
过程:
如下过程的反复迭代，直至用户确认所开发的软件完全实现其需求：
1. 快速了解与分析用户提出的需求
2. 快速设计与实现（即构造原型,mock）
3. 用户试用，提出反馈意见
特点:
用户全程参与，有助于准确理解并实现用户需求,但是，缺乏全局设计会带来的一系列弊端

### 螺旋模型
![](luoxuan.png)
是瀑布模型和演化模型的结合,并增加了风险分析。
每旋转一圈，表示开发 出一个更为完善的新软件版本 

# 计算机系统工程（了解） （考————————————点）
+ 硬件
+ 软件
+ 使用者
+ 数据库
+ 文档
+ 规程

# 需求工程 
## 需求工程的概念 （考————————————点）

## 软件需求、需求分析、需求工程的基本概念（理解）
+ 软件需求：客户对软件功能与性能所提出的、或者隐含的要求。  

    1. 核心是功能需求，包括：
    功能：软件有哪些功能。
    数据：每个功能输入哪些数据、输出哪些结果。
    行为：软件按照什么规则对输入数据进行“加工”，得到用户所需要的输出结果。  

    2. 性能需求
    高并发，流畅性，交互性。用户、客户、软件企业，对软件性能有不同的要求
    3. 环境需求
    4. 界面需求
## 需求分析过程（理解）
### 1. 获取
系统分析人员与用户交流。获取包括：  

**归结为功能和性能需求**
1. 系统/产品范围的描述
2. 系统/产品有关的人员及特征列表
3. 系统的技术环境
4. 系统功能列表及每个需求的领域限制
5. 不同环境下系统使用的场景
### 2. 分析与建模（用规范的图形工具描述需求）
#### 1. 需求分析的原则：
1. 能够表示描述软件的功能、数据与行为
2. 做好分析，能够清晰表示和理解问题的信息
3. 数据、功能、行为的模型，用“模型”描述并划分（还要用图表达出来）
#### 2. 分析与建模在做什么
1. 明确功能
    1. 从“业务流程”入手分析
    2. 针对业务流程的每个环节
    3. 明确软件要提供什么样的功能
2. 分析软件每个功能的输入输出数据
    1. 从每个功能所对应的业务场景入手分析
    2. 需要引用（之前所产生的）哪些数据
    3. 产生什么样的新的数据
3. 进一步分析，每个功能到底按什么规则处理数据
    1. 对于输入数据
        “前置数据”，完整性规则
    2. 对于输出数据
        数据源头，计算规则
    建模过程依次是：功能—数据—行为
#### 4. 需求分析的核心方法：
1. 分解：  

问题：
```
用户提出的功能需求很多，如何分析？
```
方法:
```
将大问题分解，逐层/逐个加以分析
```
2. 抽象  ：

问题：
```
用户讲的往往是“表面”上的需求如何分析？
```
方法:
```
抽象，抓住问题关键，找出内在规律运用建模方法，做出逻辑归纳。
```
3. 多视点分析：  

问题：
```
不同用户所讲的需求，好像不一样
```
方法:
```
多视点分析，加以归纳，向用户求证。
```  

### 3.需求协商
#### 1. 协商原因：
+ 需求模糊
+ 需求有死角
+ 需求有冲突
+ 需求不合理
+ 你的理解（即“抽象”）是否合适  

### 4. 需求建模
+ 结构化
+ 面向对象
无论采用哪种模型，都要求描述软件的功能、数据与行为
### 5. 需求文档
对功能、数据、行为的建模，是需求分析文档的核心内容。
### 6. 评审
对功能的正确性、完整性、清晰性和其他需求给予评价。
### 7. 管理

# 软件设计
## 软件设计包含哪些方面的内容（掌握）
1. 架构设计
2. 数据设计
    结构化方法： 数据库设计
    面向对象方法： 类设计，数据库设计
3. 模块划分，将软件划分成若干个模块
4. 在模块划分的同时，做接口设计
包含：软件内部模块之间的接口
以及：与外部软件/设备之间的接口
5. 过程设计
给出每个模块内部的算法逻辑
6. 界面原型设计
约定界面的基本风格
## 模块化、信息隐藏、模块独立性、内聚与耦合（理解）
### 1.模块化：（考————————————点）
模块化将软件划分成若干个较小、**相互独立**但又相互关联的模块，分别编程实现，方便软件的编程、测试、组装、修改与维护以及项目管理。  

模块划分之后，软件复杂度降低：
C(P1+P2)>C(P1)+C(P2)
E(P1+P2)>E(P1)+E(P2)  
### 2. 信息隐藏
1. 模块内部的数据和过程，对于那些不需要这些信息的模块不可访问（即隐藏）
2. 每一个模块只完成一个相对独立的特定功能；
3. 模块之间仅仅交换那些完成系统功能所必须交换的信息。  

### 3. 模块独立性
是模块化、信息隐藏、局部化等概念的体现。
### 4. 内聚和耦合 （考————————————点）
是模块独立性的指标
内聚： 对模块内部各元素之间关系的度量（能划分7个等级）
耦合： 对模块外部接口关系的度量（能划分7个等级）
## 过程设计的常用方法（流程图，理解） （考————————————点）
又名部件级设计
任务：
1. 为每个部件确定采用的算法，选择某种适当的工具表达算法的过程，编写部件的详细过程性描述
2. 确定每一部件内部使用的数据结构
3. 在部件级设计结束时，应该把上述结果写入部件级设计说明书，并且通过复审形成正式文档，作为下一阶段（编码）的工作依据。
## 设计规约主要包含哪些内容 （考————————————点）
1. 工作范围
2. 体系结构设计
3. 数据设计
4. 接口设计
5. 各部件的过程设计
6. 运行设计
7. 出错处理设计
8. 安全保密设计
9. 需求/设计交叉索引
10. 测试部分
11. 特殊注解
12. 附录
# 结构化分析（掌握）
## 1. 数据流图
## 2. 数据字典
## 3. 功能说明
理解实验
# 人机界面设计的主要注意事项（了解）
## 1.让用户拥有控制权
## 2.减少用户的记忆负担
## 3.保持界面一致
# 编程规范（了解）
## 标识符命名需要注意的问题 （考————————————点）
1. 名字可以反应它所代表的实体，有一定的实际意义
2. 名字不是越长越好，太长会出错且增加打字量，应当选择精炼且意义明确的名字
3. 必要时可以使用缩写名字，但是缩写规则要一致，且给缩写名字加注释
4. 不用关键字
5. 同一个名字不要有多个含义
6. 不用相似的名字，不然容易混淆
7. 避免使用容易混淆的字符
## 书写功能性注释需要注意哪些问题


1. 方便日后维护
2. 自己和别人能够看懂，现在和以后都能看懂。注释和命名符号，算法效率的 保障
# 软件测试（掌握）
## 1. 测试目的
+ **核心**：测试是为了找错、而不是为了证明没错
+ 使用人工或自动的方式来运行测试某个系统，检验系统是否满足规定的要求并确定预期结果与实际结果的差异
+ 产品上线前，对软件需求、设计方案和编码实现的核查
## 2. 测试用例
一组为了测试软件而事先设计好数据；包含输入数据与预期结果等2个部分。  
1. 运行事先准备好的测试用例；
2. 将运行结果与预期结果进行比对;
3. 以此发现软件所隐含的错误。

## 3. 白盒法与黑盒法的概念
+ 白盒法：
把测试 对象看作一个透明的盒子，测试人员 根据程序内部的逻辑结构及有关信息 设计测试用例，检查程序中所有逻辑 路径是否都按预定的要求正确地工作
>方法针对每个模块内部的运行路径进行测试
+ 黑盒法：
把测试对象看 做一个黑盒子，测试人员完全不考虑程序 内部的逻辑结构和内部特性，只依据程序 的需求规格说明书，检查程序的功能是否 符合它的功能需求

>针对每个功能的输入/输出数据进行测试
## 4. 基本路径测试，逻辑覆盖，循环覆盖，等价类，边界值
课堂测试
## 5. V模型
记住一一对应的关系
![](Vmodel.jpg)
## 6. 4类测试的对象
![](sileiduixiang.png)
## 7.任务与依据
# 软件维护
## 1.软件维护的定义与分类（理解）
软件交付运行以后所做的修改。
分类：
1. 纠错性维护—纠正错误
2. 适应性维护—适应新的运行环境
3. 改善性维护—增加新的功能、以及变更原有的功能
4. 预防性维护

## 2. 提高软件可维护性的方法（了解）
1. 做好需求分析——减少因需求变更所带来的维护
2. 设计合理——模块规模适中，高内聚低耦合
3. 规范编程——使维护人员容易读懂程序
4. 做好测试——留下测试记录
5. 规范维护流程——规避软件维护的副作用
只有从一开始就意识到维护的重要性，做好每一项工作，才能保障软件有良好的可维护性。



    



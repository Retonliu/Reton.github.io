---
title: 软件工程复习笔记
date: 2020-01-14 09:12
tags: 软件工程
---

# 计算机软件（了解）
## 软件的基本概念 （重点）
计算机系统中的**程 序**及其**文档** 
## 软件的特点
+ 软件是**逻辑**实体，其开发**成本和进度难以准确地 估算** 
+ 软件**没有明显的制造过程**，一旦开发成功，只需**复制** 即可，但其**维护**的工作**量大** 
+ 软件**没有**硬件**磨损**和 **老化**问题
+ 对计算机**硬件**有**依赖**性 
+ **尚未**完全实现**自动化** 
+ **成本**相当**昂贵**
+ **社会**因素
## 软件的分类
+ 系统软件，最靠近硬件的。如操作系统
+ 支撑软件，支持软件开发维护的软件。如数据库管理系统
+ 应用软件，特定领域专用软件，如嵌入式应用软件
# 软件工程（掌握）
## 软件工程的基本概念（重点）
将系统化的、严格约束的、 可量化的方法应用于软件的开发、运行和维护，即 将工程化应用于软件
+ 系统化：软件开发过程要形成体系。
+ 有约束：每个阶段的工作要有既定的规则。
+ 可量化：对每个阶段的工作，事先计划与事后评价应该[在一定程度上的]有可量化的标准。
+ 全过程：软件开发时不仅要考虑当前，而且还要考虑日后的维护。
## 软件生存周期
1. 项目规划
2. 需求分析
3. 软件设计
4. 编码实现
5. 软件测试
6. 交付/发布
7. [实施]
8. 运行与维护
9. 弃用
其中
+ 从整个软件生命周期的角度，分为前期规划、软件开发、运行维护等3大阶段。
+ 软件开发分为需求分析、设计、实现与测试等4个阶段。
# 软件过程（理解）
## 概念
软件开发的步骤
## 主要模型的原理与特点
### 瀑布模型
![](pubu.png)
与经典的软件生命周期一致
特点：
1. 文挡驱动，比较正规，同时也比较繁琐；
2. 过程清晰，容易推行；
3. 纠正前期工作错误的代价昂贵
缺点:
1. 不容易一开始就确切掌握软件需求
2. 如果第一点没做好,问题要到开发完成并交付用户之后才暴露
3. 出现问题要大量推翻之前的工作成果,代价巨大
### 原型模型
![](yuanxing.png)
概念: 能够反映预期系统部分特征的一个可执行版本  
过程:
如下过程的反复迭代，直至用户确认所开发的软件完全实现其需求：
1. 快速了解与分析用户提出的需求
2. 快速设计与实现（即构造原型,mock）
3. 用户试用，提出反馈意见
特点:
用户全程参与，有助于准确理解并实现用户需求,但是，缺乏全局设计会带来的一系列弊端

### 螺旋模型
![](luoxuan.png)
是瀑布模型和演化模型的结合,并增加了风险分析。
每旋转一圈，表示开发 出一个更为完善的新软件版本 

# 计算机系统工程（了解）
+ 硬件
+ 软件
+ 使用者
+ 数据库
+ 文档
+ 规程

# 需求工程
## 软件需求、需求分析、需求工程的基本概念（理解）
+ 软件需求：客户对软件功能与性能所提出的、或者隐含的要求。  

    1. 核心是功能需求，包括：
    功能：软件有哪些功能。
    数据：每个功能输入哪些数据、输出哪些结果。
    行为：软件按照什么规则对输入数据进行“加工”，得到用户所需要的输出结果。  

    2. 性能需求
    高并发，流畅性，交互性。用户、客户、软件企业，对软件性能有不同的要求
+ 需求分析：对软件需求的获取、理解、分析与描述。
+ 需求工程：用软件工程方法做需求分析的过程。
## 需求分析过程（理解）
### 1. 获取
系统分析人员与用户交流。获取包括：  

**归结为功能和性能需求**
1. 系统/产品范围的描述
2. 系统/产品有关的人员及特征列表
3. 系统的技术环境
4. 系统功能列表及每个需求的领域限制
5. 不同环境下系统使用的场景
### 2. 分析与建模（用规范的图形工具描述需求）
#### 1. 需求分析的原则：
1. 能够表示描述软件的功能、数据与行为
2. 做好分析，能够清晰表示和理解问题的信息
3. 数据、功能、行为的模型，用“模型”描述并划分（还要用图表达出来）
#### 2. 分析与建模在做什么
1. 明确功能
    1. 从“业务流程”入手分析
    2. 针对业务流程的每个环节
    3. 明确软件要提供什么样的功能
2. 分析软件每个功能的输入输出数据
    1. 从每个功能所对应的业务场景入手分析
    2. 需要引用（之前所产生的）哪些数据
    3. 产生什么样的新的数据
3. 进一步分析，每个功能到底按什么规则处理数据
    1. 对于输入数据
        “前置数据”，完整性规则
    2. 对于输出数据
        数据源头，计算规则
    建模过程依次是：功能—数据—行为
#### 4. 需求分析的核心方法：
1. 分解：  

问题：
```
用户提出的功能需求很多，如何分析？
```
方法:
```
将大问题分解，逐层/逐个加以分析
```
2. 抽象  ：

问题：
```
用户讲的往往是“表面”上的需求如何分析？
```
方法:
```
抽象，抓住问题关键，找出内在规律运用建模方法，做出逻辑归纳。
```
3. 多视点分析：  

问题：
```
不同用户所讲的需求，好像不一样
```
方法:
```
多视点分析，加以归纳，向用户求证。
```
### 3.需求协商
#### 1. 协商原因：
+ 需求模糊
+ 需求有死角
+ 需求有冲突
+ 需求不合理
+ 你的理解（即“抽象”）是否合适
### 4. 需求建模
#### 1. 是什么
以图形、或者其它形式化工具描述需求
#### 2. 有什么用
可以清楚、准确、规范地描述系统的全局，包括：
+ 系统由哪些元素所构成
+ 每个系统元素的作用是什么
+ 系统内部各元素之间的相互关系
#### 3. 建模方法
+ 结构化
+ 面向对象
无论采用哪种模型，都要求描述软件的功能、数据与行为
### 5. 需求文档
#### 1. 什么是需求规约
+ 对软件需求分析结果作出书面描述
+ 作为需求分析阶段工作的最终成果。
#### 3. 基本原则
**核心：应描述系统“做什么”、而不是“怎么实现”**
+ 做什么——需求阶段，描述用户看到的软件
    + 系统有哪些功能
    + 每个功能需要输入/输出哪些数据
    + 按照什么行为规则处理这些数据
+ 怎么实现——设计阶段，描述开发者要做的软件
    描述系统内部的数据结构、模块构成、以及模块内部的逻辑处理过程
+ 做好需求分析的关键
    对用户业务的理解、分析与描述，而不是计算机专业的知识。
#### 4. 文档格式
对功能、数据、行为的建模，是需求分析文档的核心内容。
### 6. 评审
对功能的正确性、完整性、清晰性和其他需求给予评价。
### 7. 管理
# 软件设计
## 软件设计包含哪几方面的内容（掌握）
## 模块化、信息隐藏、模块独立性、内聚与耦合（理解）
## 过程设计的常用方法（流程图，理解）

# 软件设计
## 软件设计包含哪些方面的内容（掌握）
1. 架构设计
2. 数据设计
    结构化方法： 数据库设计
    面向对象方法： 类设计，数据库设计
3. 模块划分，将软件划分成若干个模块
4. 在模块划分的同时，做接口设计
包含：软件内部模块之间的接口
以及：与外部软件/设备之间的接口
5. 过程设计
给出每个模块内部的算法逻辑
6. 界面原型设计
约定界面的基本风格
## 模块化、信息隐藏、模块独立性、内聚与耦合（理解）
### 1.模块化：
模块化将软件划分成若干个较小、**相互独立**但又相互关联的模块，分别编程实现，方便软件的编程、测试、组装、修改与维护以及项目管理。  

模块划分之后，软件复杂度降低：
C(P1+P2)>C(P1)+C(P2)
E(P1+P2)>E(P1)+E(P2)  
### 2. 信息隐藏
1. 模块内部的数据和过程，对于那些不需要这些信息的模块不可访问（即隐藏）
2. 每一个模块只完成一个相对独立的特定功能；
3. 模块之间仅仅交换那些完成系统功能所必须交换的信息。
### 3. 模块独立性
是模块化、信息隐藏、局部化等概念的体现。
### 4. 内聚和耦合
是模块独立性的指标
内聚： 对模块内部各元素之间关系的度量（能划分7个等级）
耦合： 对模块外部接口关系的度量（能划分7个等级）
## 过程设计的常用方法（流程图，理解）
# 结构化分析（掌握）
理解实验
# 人机界面设计的主要注意事项（了解）
## 1.让用户拥有控制权
## 2.减少用户的记忆负担
## 3.保持界面一致
# 编程规范（了解）
1. 方便日后维护
2. 自己和别人能够看懂，现在和以后都能看懂。注释和命名符号，算法效率的 保障
# 软件测试（掌握）
## 1. 测试目的
+ **核心**：测试是为了找错、而不是为了证明没错
+ 使用人工或自动的方式来运行测试某个系统，检验系统是否满足规定的要求并确定预期结果与实际结果的差异
+ 产品上线前，对软件需求、设计方案和编码实现的核查
## 2. 测试用例
一组为了测试软件而事先设计好数据；包含输入数据与预期结果等2个部分。  
1. 运行事先准备好的测试用例；
2. 将运行结果与预期结果进行比对;
3. 以此发现软件所隐含的错误。

## 3. 白盒法与黑盒法的概念
+ 白盒法：
把测试 对象看作一个透明的盒子，测试人员 根据程序内部的逻辑结构及有关信息 设计测试用例，检查程序中所有逻辑 路径是否都按预定的要求正确地工作
>方法针对每个模块内部的运行路径进行测试
+ 黑盒法：
把测试对象看 做一个黑盒子，测试人员完全不考虑程序 内部的逻辑结构和内部特性，只依据程序 的需求规格说明书，检查程序的功能是否 符合它的功能需求

>针对每个功能的输入/输出数据进行测试
## 4. 基本路径测试，逻辑覆盖，循环覆盖，等价类，边界值
课堂测试
## 5. V模型
记住一一对应的关系
![](Vmodel.png)
## 6. 4类测试的对象
![](sileiduixiang.png)
## 7.任务与依据
# 软件维护
## 1.软件维护的定义与分类（理解）
软件交付运行以后所做的修改。
分类：
1. 纠错性维护—纠正错误
2. 适应性维护—适应新的运行环境
3. 改善性维护—增加新的功能、以及变更原有的功能
4. 预防性维护

## 2. 提高软件可维护性的方法（了解）
1. 做好需求分析——减少因需求变更所带来的维护
2. 设计合理——模块规模适中，高内聚低耦合
3. 规范编程——使维护人员容易读懂程序
4. 做好测试——留下测试记录
5. 规范维护流程——规避软件维护的副作用
只有从一开始就意识到维护的重要性，做好每一项工作，才能保障软件有良好的可维护性。




    



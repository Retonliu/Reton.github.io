---
title: 树的路径和
date: 2020-12-24 19:14
tags: 
- 树
- 算法
---
# 路径总和I
>题目地址： https://leetcode-cn.com/problems/path-sum/
思路：
1. 最小子问题：
    1. 如果当前节点是叶子节点，且满足当前叶节点的值是所要求的值则返回true
    2. 如果已经到了空节点则返回false。因为会走到空节点则说明上一个叶节点是不满足要求的。
2. 整体逻辑，判断当前节点的值是否是叶子节点并判断叶子节点的值是否满足要求，否则就判断左右子树，**每次传给左右子树的target都是减去当前的节点值，因为当前节点就已经属于走过的节点了，包含在路径里面**。

代码：
```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
    if (root === null) {
        return false;
    }
    if (sum === root.val && root.left === null && root.right === null) {
        return true;
    }
    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
};
```

# 路径总和II
>题目地址：https://leetcode-cn.com/problems/path-sum-ii
思路：
1. 整体逻辑：  
    1. 判断当前是否为空节点，如果是则不符合条件返回
    2. 如果是叶节点，则判断是否符合要求，符合要求的话就把当前数组copy然后push到res当中，注意要重新创建一个数组，不然存进去一个引用，后续修改都会导致res里面的结果发生变化。然后递归左子树，再递归右子树。然后记住要tmp.pop(),不然左子树的值存在tmp里面，影响了右子树的时候tmp里面的值。**还有一个就是子问题符合情况的时候也要记得pop，保证什么情况，左子树的过程都不会影响到右子树的过程。**
2. 最小子问题：
    1. 空节点
    2. 叶子节点
代码：
```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var pathSum = function(root, sum) {
    let res = [],
        tmp = [];
    function dfs(cur, sum) {
        if (cur === null) {
            return ;
        }
        tmp.push(cur.val);
        if (sum === cur.val && cur.left === null && cur.right === null) {
            res.push([...tmp]);
            tmp.pop();
            return ;
        }
        dfs(cur.left, sum - cur.val);
        dfs(cur.right, sum - cur.val);
        tmp.pop();
    }
    dfs(root, sum);
    return res;
};
```

# 路径总和III
> 题目地址：https://leetcode-cn.com/problems/path-sum-iii/

思路：前面两道要求的路径都是从根节点开始，到了第三道情况一百八十度大转变，突然变成了从任意节点开始，但是树一般都是用递归的，递归一般都是从根节点开始的，这波直接把我难住了。后面了解到了前缀和这种东西，可以帮我解决从根节点转换为非根节点。前缀和就是表示从根节点到当前节点路径总和，所以如果要求两个节点之间的距离且不用从根节点出发，那么只要找到两个节点的前缀和之差满足条件即可，前缀和的差表示的路径就是两个节点之间的路径，没有经过根节点。 **这里就引出了一个大坑，前缀和的差为0的时候，表示的就是从根节点到当前节点，所以一开始初始化的时候要把map初始化一个（0，1）的键值对**

代码:
```
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {number}
 */
var pathSum = function(root, target) {
    let map = new Map(), //前缀和映射
        res = 0;
    map.set(0, 1); //这里表示的是从根节点到当前节点
    function dfs(cur, sum) {
        if (cur === null) {
            return ;
        }

        sum += cur.val;
        res += map.get(sum - target) || 0; //res有sum-target前缀和对应方法数的数

        map.set(sum, (map.get(sum) || 0) + 1); //增加一个当前前缀和，让递归的子树可以使用

        dfs(cur.left, sum);
        dfs(cur.right, sum);

        map.set(sum, map.get(sum) - 1); //防止影响到另一边的计算，因为这道题要求的是一直往下的
    }
    dfs(root, 0);
    return res;
};
```
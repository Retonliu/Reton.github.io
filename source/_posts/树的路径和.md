---
title: 树的路径和
date: 2020-12-24 19:14
tags: 
- 树
- 算法
---
# 路径总和I
>题目地址： https://leetcode-cn.com/problems/path-sum/
思路：
1. 最小子问题：
    1. 如果当前节点是叶子节点，且满足当前叶节点的值是所要求的值则返回true
    2. 如果已经到了空节点则返回false。因为会走到空节点则说明上一个叶节点是不满足要求的。
2. 整体逻辑，判断当前节点的值是否是叶子节点并判断叶子节点的值是否满足要求，否则就判断左右子树，**每次传给左右子树的target都是减去当前的节点值，因为当前节点就已经属于走过的节点了，包含在路径里面**。

代码：
```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
    if (root === null) {
        return false;
    }
    if (sum === root.val && root.left === null && root.right === null) {
        return true;
    }
    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
};
```

# 路径总和II
>题目地址：https://leetcode-cn.com/problems/path-sum-ii
思路：
1. 整体逻辑：  
    1. 判断当前是否为空节点，如果是则不符合条件返回
    2. 如果是叶节点，则判断是否符合要求，符合要求的话就把当前数组copy然后push到res当中，注意要重新创建一个数组，不然存进去一个引用，后续修改都会导致res里面的结果发生变化。然后递归左子树，再递归右子树。然后记住要tmp.pop(),不然左子树的值存在tmp里面，影响了右子树的时候tmp里面的值。**还有一个就是子问题符合情况的时候也要记得pop，保证什么情况，左子树的过程都不会影响到右子树的过程。**
2. 最小子问题：
    1. 空节点
    2. 叶子节点
代码：
```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var pathSum = function(root, sum) {
    let res = [],
        tmp = [];
    function dfs(cur, sum) {
        if (cur === null) {
            return ;
        }
        tmp.push(cur.val);
        if (sum === cur.val && cur.left === null && cur.right === null) {
            res.push([...tmp]);
            tmp.pop();
            return ;
        }
        dfs(cur.left, sum - cur.val);
        dfs(cur.right, sum - cur.val);
        tmp.pop();
    }
    dfs(root, sum);
    return res;
};
```
---
title: 目标和
date: 2020-12-13 11:02
tags:
- 动态规划
- 算法
---

>题目地址： https://leetcode-cn.com/problems/target-sum/

思路： 这道题可以看作是背包问题的变体。跟01背包问题不一样的地方在于，01背包问题只需要考虑，当前容量加进这个物品之后，剩余的容量的子问题即dp[i][j]对应于dp[i-1][j-nums[i]],而在这里还需要考虑另外一种情况就是dp[i-1][j+nums[i]]，后者这个情况的意思就是更高容量的子问题，因为可以从更高容量的子问题直接拿掉当前物品的重量得到的就是当前容量。即
dp[i][j] = dp[i-1][j+nums[i]] + dp[i-1][j-nums[i]]; 所以跟背包问题有以下两点不同：
1. 在构建背包问题的思维图的时候，需要考虑两边的情况即有负方向的子问题还有正方向的子问题。 
2. 在构建背包问题的思维图的时候，范围不再是0到S（所求容量），因为所求容量S不仅仅是从0开始的子问题推导过来，还有可能从大于S的正方向推到过来以及从小于0的负方向推导过来，所以要求的范围是从-SUM到+SUM
3. 由于负方向的容量会导致出现数组的下标为负数的情况，而在编程语言种，数组的下标不可以是负数，所以还需要考虑数组下标是负数的时候，出现越界的情况。 这里一个比较直接的做法就是，在每个容量的下标即dp数组的二维下标中，每个下标都要加上sum，这就是相当于把整个思维图向右移动了sum个格子，因为最小为-sum，这样就保证了思维图中的每个格子的数组下标都是大于0的。

踩过的坑：
1. 判断数组是否越界的时候，一开始我是写成这样子：
```
if ( (j + nums[i]) > sum || (j - nums[i]) < -sum ) {
        continue;
}
dp[i][j] = dp[i-1][j+nums[i]] + dp[i-1][j-nums[i]];
```
结果一直得到错误的结果，想了挺久之后发现，即使有一个方向不满足要求，但是如果另一个方向满足要求的话，当前容量也是大于0的，所以不能一个方向不满足就直接跳过，而是应该同时考虑两个方向。所以应该改成以下代码:
```
 if (j + nums[i] > sum) {
                tmp1 = 0;
            } else {
                tmp1 = dp[i-1][j + nums[i] + sum];
            }
            if (j - nums[i] < -sum) {
                tmp2 = 0;
            } else {
                tmp2 = dp[i-1][j - nums[i] + sum];
            }
            //全部加上sum实现整个表格往右移动sum个格子的效果
            dp[i][j+sum] = tmp1 + tmp2;  
```

2. 对于背包思维图中的每一个数组表示，第二维度的下标都应该加上sum。
一开始我忘记给dp[i][j]的j加上sum，写成这样：
```
dp[i][j] = tmp1 + tmp2;  
```
所以一直得到错误的结果，后面恍然大悟，改成这样之后就成功AC：
```
dp[i][j+sum] = tmp1 + tmp2; 
```

未考虑越界情况(易于理解):
```
/**
 * @param {number[]} nums
 * @param {number} S
 * @return {number}
 */
var findTargetSumWays = function(nums, S) {
    let len = nums.length, sum = 0;
    for (let i = 0; i < len; i++) {
        sum += nums[i];
    }
    if (sum < Math.abs(S)) {
        return 0;
    }
    //sum = sum * 2 + 1;
    //dp[i][j]表示对于前i个物品，容量为j的时候有dp[i][j]种方法装满这个背包
    let dp = new Array(len).fill(0).map(item => new Array(sum * 2 + 1)); 
    //初始化，其他情况都是0，只有nums[0]的情况下才有可能是方法数是1
    dp[0][nums[0]] = 1;
    dp[0][-nums[0]] += 1;  // 对于nums[0]的特例， +-0得到0算两种方法
    for (let i = 1; i < len; i++) {
        for (let j = -sum; j <= sum; j++) {
            if (j + nums[i] > sum) {
                tmp1 = 0;
            } else {
                tmp1 = dp[i-1][j + nums[i] + sum];
            }
            if (j - nums[i] < -sum) {
                tmp2 = 0;
            } else {
                tmp2 = dp[i-1][j - nums[i] + sum];
            }
            //全部加上sum实现整个表格往右移动sum个格子的效果
            dp[i][j+sum] = tmp1 + tmp2;  
        }
    }
    return dp[len-1][S];
};
```

考虑越界的代码:
```
/**
 * @param {number[]} nums
 * @param {number} S
 * @return {number}
 */
var findTargetSumWays = function(nums, S) {
    let len = nums.length, sum = 0, tmp1 = 0, tmp2 = 0;
    for (let i = 0; i < len; i++) {
        sum += nums[i];
    }
    if (sum < Math.abs(S)) {
        return 0;
    }
    //dp[i][j]表示对于前i个物品，容量为j的时候有dp[i][j]种方法装满这个背包
    let dp = new Array(len).fill(0).map(item => new Array(sum * 2 + 1).fill(0)); 
    //初始化，其他情况都是0，只有nums[0]的情况下才有可能是方法数是1
    dp[0][nums[0] + sum] = 1;
    dp[0][-nums[0] + sum] += 1;  // 对于nums[0]的特例， +-0得到0算两种方法
    for (let i = 1; i < len; i++) {
        for (let j = -sum; j <= sum; j++) {
            //加上if条件，去除数组越界的情况，因为j - nums[i]可能小于-sum
            if (j + nums[i] > sum) {
                tmp1 = 0;
            } else {
                tmp1 = dp[i-1][j + nums[i] + sum];
            }
            if (j - nums[i] < -sum) {
                tmp2 = 0;
            } else {
                tmp2 = dp[i-1][j - nums[i] + sum];
            }
            //全部加上sum实现整个表格往右移动sum个格子的效果
            dp[i][j+sum] = tmp1 + tmp2;  
        }
    }
    return dp[len - 1][S + sum];
};
```
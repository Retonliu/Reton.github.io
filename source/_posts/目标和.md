---
title: 目标和
date: 2020-12-06 21:47
tags:
- 动态规划
- 算法
---

>题目地址： https://leetcode-cn.com/problems/target-sum/

思路： 这道题可以看作是背包问题的变体。区别在于如果要填满当前的容量，有两种方法，一种是类似于01背包那样子，直接当前容量减去当前物品，等于容量更小的子问题。但是还有另外一种情况，就是可以从背包种取出当前重量的物品，子问题是容量更大的情况。所以计算dp[i][j]需要同时考虑dp[i-1][j-nums[i]]和dp[i-1][j+nums[i]]。由于要计算的容量S可能来自于很多种情况，相比之下01背包问题只需要考虑比所给的容量S小的情况就行，在这道题种，需要考虑的最大容量是所有物品的正数之和，而最小的容量则是把所有物品取出来之后的容量，即所有物品之和的负数。   **由于数组的下标不允许出现负数，所以整个背包问题的思维图需要整体向右移动sum个格子，即最小负数-sum变为0**，同时注意第一个数是+0和-0的情况。 至于这里为什么，不满足可以取子状态的时候，当前dp[i][j]值是0而不是像01背包问题那样子取dp[i-1][j-1]呢？是因为dp所代表的含义不同，01背包问题那里dp代表的是价值，而这里dp代表的是方法数。

未考虑越界情况:
```
/**
 * @param {number[]} nums
 * @param {number} S
 * @return {number}
 */
var findTargetSumWays = function(nums, S) {
    let len = nums.length, sum = 0;
    for (let i = 0; i < len; i++) {
        sum += nums[i];
    }
    if (sum < Math.abs(S)) {
        return 0;
    }
    //sum = sum * 2 + 1;
    //dp[i][j]表示对于前i个物品，容量为j的时候有dp[i][j]种方法装满这个背包
    let dp = new Array(len).fill(0).map(item => new Array(sum * 2 + 1)); 
    //初始化，其他情况都是0，只有nums[0]的情况下才有可能是方法数是1
    dp[0][nums[0]] = 1;
    dp[0][-nums[0]] += 1;  // 对于nums[0]的特例， +-0得到0算两种方法
    for (let i = 1; i < len; i++) {
        for (let j = -sum; j <= sum; j++) {
            dp[i][j] = dp[i-1][j+nums[i]] + dp[i-1][j-nums[i]];
        }
    }
    return dp[len-1][S];
};
```
---
title: 目标和
date: 2020-12-06 21:47
tags:
- 动态规划
- 算法
---

>题目地址： https://leetcode-cn.com/problems/target-sum/

思路： 这道题可以看作是背包问题的变体。区别在于如果要填满当前的容量，有两种方法，一种是类似于01背包那样子，直接当前容量减去当前物品，等于容量更小的子问题。但是还有另外一种情况，就是可以从背包种取出当前重量的物品，子问题是容量更大的情况。所以计算dp[i][j]需要同时考虑dp[i-1][j-nums[i]]和dp[i-1][j+nums[i]]。由于要计算的容量S可能来自于很多种情况，相比之下01背包问题只需要考虑比所给的容量S小的情况就行，在这道题种，需要考虑的最大容量是所有物品的正数之和，而最小的容量则是把所有物品取出来之后的容量，即所有物品之和的负数。   **由于数组的下标不允许出现负数，所以整个背包问题的思维图需要整体向右移动sum个格子，即最小负数-sum变为0**，同时注意第一个数是+0和-0的情况。

代码如下：
```
/**
 * @param {number[]} nums
 * @param {number} S
 * @return {number}
 */
var findTargetSumWays = function(nums, S) {
    let sum = 0,
        len = nums.length,
        tmp1 = 0,
        tmp2 = 0;
    
    for (const num of nums) {
        sum += num; //计算所有可能区间
    }
    if (Math.abs(S) > sum) {
        return 0;
    }
    let tmp = sum * 2 + 1;
    let dp = new Array(len).fill(0).map(item => new Array(tmp).fill(0));
    dp[0][sum-nums[0]] = 1;
    dp[0][sum+nums[0]] += 1;
    for (let i = 1; i < len; i++) {
        for (let j = 0; j < tmp; j++) {
            if (j - nums[i] >= 0) {
                tmp1 = dp[i-1][j-nums[i]];
            } else {
                tmp1 = 0;
            }
            if (j + nums[i] < tmp) {
                tmp2 = dp[i-1][j+nums[i]];
            } else {
                tmp2 = 0;
            }
            dp[i][j] = tmp1 + tmp2;
        }
    }
    return dp[len-1][sum+S];
};

```
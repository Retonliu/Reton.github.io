---
title: 累加树
date: 2020-12-23 16:08
tags: 
- 树
- 算法
---

思路：看到题目想到了两个比较直接的思路
1. 层次遍历为一个数组，然后利用父节点与子节点下标的关系，循环进行判断
2. 中序遍历为一个数组，然后使用分支的做法，每一个节点左边一定小于当前节点，右边一定大于当前节点，
*但是这两种做法，都是先生成一个数组，然后后续进行判断，经验告诉我，这样做是不可取的，正确的做法应该是一边遍历，一遍进行判断的。*

其实第二个做法还没有想的足够彻底，因为这道题涉及到的树是搜索树，搜索树的中序遍历是有更明显的特性，即它的中序遍历数组是一个升序的数组。所以可以利用这一点来完成，当然重要的一点就是我上面说的，要在递归的同时做判断。所以要判断一棵树是不是升序的，就判断每次遍历到一个节点的时候，就判断它是否比上个节点的值大，这变相完成了升序的判断，为什么能这么做呢，因为对于每一个节点，由于是中序遍历的，所以它的上一个节点肯定是它的左节点，左节点如果符合搜索树的特征，那它一定是要小于当前节点的，所以每一次都把遍历的上一个节点给记录下来，在递归的过程中进行判断。 

总结：

+ 中序遍历，所以先遍历左节点，后当前结点，然后右节点
+ 搜索树要满足，左子树小于当前，右子树大于当前
+ 综上，得到的就是一个递增的数组。所以灵机一动，只要保留当前结点的上一结点的值即可。

**根据递归的两个重要的思维方式**：

1. 在整体逻辑上进行思考。所以在第一层，即还没有递归的时候，整体上，就是**判断左子树是否满足条件**，然后**判断当前节点是否满足条件**，注意当前节点是否满足条件要在递归左子树之后，因为是中序遍历，所以要递归左子树之后才能获取当前节点的前一个节点。 然后**判断右子树是否满足条件**，**返回的值就是左右两个子树的结果**。
2. 最小的问题，最小的问题就是递归到节点为空时候开始返回，即一开始一直往左边递归，递归到最左最下的节点的左子树为空，返回一个true，判断最左最下的节点是否满足条件，再递归到最左最下的节点的右子树为空（这里假设最左最下节点左右子树均为空），然后就完成了最小子问题的判断

代码:
```
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
    let preVal = -Number.MAX_VALUE;
    function dfs(cur) {
        if (cur === null) {
            return true;
        }
        
        let left = dfs(cur.left);

        if (cur.val <= preVal) {
            return false;
        }
        preVal = cur.val;

        let right = dfs(cur.right);
        return left && right;
    }
    return dfs(root);
};
```
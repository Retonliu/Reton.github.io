---
title: 机器数
date: 2020-08-25 16:24:43
tags: 
- 计算机组成原理
- 计算机系统
---
#机器数在计算机内部可分为无符号数和有符号数
无符号数：没有正负之分，所有的数都是正数
有符号数：有正负之分，在符号位用0表示正数，用1表示负数。  

* 无符号数在计算机内部的存储情况比较简单，把数据转为二进制格式，按照数据存储的硬件（寄存器或者存储器）的位数来存储。
比如 如果要存的寄存器是8位的,![](1.png)
要存的数是4，先把4变为二进制格式：100，然后高位补0，变为00000100，放入寄存器即可。
* 有符号数的存储需要在硬件中把位数中的最高位用于表示正负（0，1），**注意符号数是不影响数据绝对值大小的**，其余的位用于表示数的绝对值大小。 平常我们接触的数据又可以分为整数和小数两种方式。所以需要对小数点的位置进行处理。
存储小数的时候，小数点表示在符号位的后一位。如下图所示：
![](2.png)
存储整数的时候，小数点放在数值的最后一位。如下图所示：
![](3.png)
**注意实际上在寄存器中是没有专门用一个位数来存储小数点的，这只是一种约定的表示方法**  
  

##机器数表示方式
* 原码 ：在上面的存储过程种运用到了把符号数值化的方法，也叫做原码表示法。  
>* 小数原码表示：
![](4.png)
**其中负数表示 1-x 即为在小数点前面加上一个1。因为小数的都是小于1的**
x是真值。比如，如果x是+0.1010，则它的原码表示法为 0.1010。如果x是 -0.1010,则它的原码表示法为
 >1 - x = 1 - (-0.1010) = 1.1010,也就是在把小数点前面的数改为 1。  
>* 整数原码表示：
![](5.png)
**其中2^n是表示在x的最高位的前面加上一个 1**
x是真值。比如，如果x是+1010，则它的原码表示法为 0,1010。如果x是 -0101，则它的原码表示法为 
2^4 - （-0101） = 1,1010。  
*整数和小数的区别就是用逗号或小数点隔开符号位，注意无论是逗号还是符号都是没有在硬件中表示出来的。*
但是用原码表示也是有问题的，在进行算术运算的时候，如果是一个正数加上一个负数实际上进行的是减法运算，这样就会使得算术运算变得麻烦，所以需要引进另一种表示方式，来使得减法变为加法，即使得计算机只需要进行加法一种运算。

* 补码
在讲补码的表达式之前，先来讲一下补码的由来。从时钟的概念来引入，假设现在是0点，那么要到达3点有两种方法，第一种是按照顺时针绕，走3个格即+3，第二种方法按照逆时针绕，走9个格即-9（反方向用减）。所以在这里+3和-9就是等价的。称+3是-9以12为模的补数。一个负数加上“模”就等于它的补数（它们的绝对值之和就等于模数）。补数引入到计算机中就得到了补码的概念，机器数在硬件中的存储也是类似的，存储空间的位数是给定的，比如给定一个8位的寄存器，那么如果要存储的数值超过8位，超出的数位就会丢失，跟时钟一个道理，超过12，超出的就会没了。假设计算-1011和+0101的补码，通过分别加上模数10000可得补数分别为+0101，+0101（高位丢掉），可以看出正数补码等于原码，由此引出一下补码定义：
> * 小数补码：
![](6.png)
正数补码等于原码。所以看一下负数的补码，若x = -0.1100000, 则其补码为2 + （-0.1100000） = 10.0000000 - 0.1100000 = 1.0100000
> * 整数补码：
![](7.png)
正数补码等于原码。看一下负数的补码，若x = -1100，原码为：1,1100则其补码为                        
2^（4+1）+ （-1100） = 100000 - 1100 = 1,0100
但是看得出来通过公式来计算补码太过于麻烦。观察求补码的过程可以发现，模数都是一个1后面带着一串0，以上面的例子来说，可以发现100000 - 1100 = 11111 - 1100 + 1， 11111 - 1100的过程可以看出来每一位相减的时候，1减去0等到1， 1减去1等于0, 等于对1100每一位都进行取反，最后再加上1。所以可以总结出求补码的快捷方式:**对于负数的补码，将负数的原码除符号位外其他全部位数取反然后加上一即可得到负数的补码**。  
  
*反码
>* 小数反码表示：
![](8.png)
0的机器数
0的机器数是特殊的，+0的原码为0.0000，-0的原码为1.000,而+0和-0的补码均为0.0000.
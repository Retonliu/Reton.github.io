---
title: 多数元素
date: 2020-11-22 14:35
tags:
- 分治算法
- 算法
---

>题目地址：https://leetcode-cn.com/problems/majority-element/

思路：使用分支算法的思路。每次都把nums分成两半，终止条件为当前区间的low === high，即此时只有一个元素，那么这个元素就一定是当前区间的多数元素。然后逐渐将两个小的区间合并为一个大的区间，合并后会出现如下情况：
1. 如果大的区间的左右两个小区间所返回的多数元素是一样的，那么此时这个大的区间的多数元素就是这个多数元素
2. 如果左右两个区间所返回的多数元素不相同，那么就调用count方法，计算在这个大的区间当中，左右小区间分别返回的left和right哪一个在大的区间中出现的次数比较多，出现次数比较多的那个就是当前大区间的多数元素。

代码：
```
/**
 * @param {number[]} nums
 * @return {number}
 */
function count(left, right, l, h, nums) {
    let leftCount = 0,
        rightCount = 0;
    for (let i = l; i <= h; i++) {
        if (nums[i] === left) {
            leftCount++;
            continue;
        }
        if (nums[i] === right) {
            rightCount++;
        }
    }
    return [leftCount, rightCount];
}

function divide(l, h, nums) {
    if (l >= h) {
        //只有一个元素的时候，这个元素肯定就是这个区间内的多数元素
        return nums[l];
    }

    //如果不只一个元素，那就继续分
    const m = Math.floor((h - l) / 2 + l);
    const left = divide(l, m, nums);
    const right = divide(m + 1, h, nums);
    
    if (left === right) {
        //如果左边和右边两个区间得到的是同一个
        return left;
    }

    //如果左边和右边不相等的话，那就得测一下合并之后区间内，lef和right哪一个的次数更多
    const [leftCount, rightCount] = count(left, right, l, h, nums);
    return leftCount > rightCount ? left : right;
}
var majorityElement = function(nums) {
    return divide(0, nums.length-1, nums);
};
```
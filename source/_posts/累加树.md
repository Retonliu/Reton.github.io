---
title: 累加树
date: 2020-12-21 10:07
tags: 
- 树
- 算法
---

>题目地址:https://leetcode-cn.com/problems/convert-bst-to-greater-tree/

思路：一开始看了题目之后，知道是往右边找（注意是右边不是右子树），找完再更新当前节点的值，所以写出了下面那个错误代码，当递归右子树的时候，使用默认值的0，因为右边的节点不需要用到当前节点的值；当递归左子树的时候，传入当前值，然后就觉得自己完成了一道完美的代码，结果一测试立即啪啪打脸，因为这种做法，当前节点的左子树的右子树拿不到当前节点的值，而左子树的右子树是肯定比当前节点小得所以它需要当前节点得值，按照我下面那个错误的代码，当遍历右子树的时候是没有传入值，所以直接失败。  看了题解之后恍然大悟，被自己蠢哭，不需要传入参数和返回值那些，只需要在闭包中多加一个sum，每次递归完右边部分，当前的sum就是右边的累加和，然后加上当前值，这样的话，**当递归到左子树的右子树的时候，由于是反向的中序遍历，所以此时当前节点的左子树的右子树是快于当前节点的左子树的（因为反向中序遍历是遍历完右子树才会开始更新当前节点的值），在这个时候，此时的闭包中的sum值仍然是当前节点的值没有包括当前节点的左子树的值，直接更新就可以了。**

错误的代码:
```
var convertBST = function(root) {
    function dfs(cur, pVal = 0) {
        if (cur === null) {
            return 0;
        }
        cur.val += dfs(cur.right) + pVal;
        let res = cur.val + (cur.left ? cur.left.val : 0);
        dfs(cur.left, cur.val);
        return res;
    }
    dfs(root);
    return root;
};
```

正确的代码：
```
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var convertBST = function(root) {
    let sum = 0;
    function dfs(cur) {
        if (cur === null) {
            return 0;
        }
        dfs(cur.right);
        sum += cur.val;
        cur.val = sum;
        dfs(cur.left);
    }
    dfs(root);
    return root;
};
```
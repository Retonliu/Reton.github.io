---
title: 累加树
date: 2020-12-23 13:51
tags: 
- 树
- 算法
---

>题目地址:https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list

思路：这道题就是把二叉树展开为先序遍历的节点顺序。**重点就是记录下先序遍历的上一个节点。**从题目可以看出，对于左子树展开成链表是比较自然的，但是当递归到右子树的时候，需要先记录下左边的节点，方便后续操作。通俗来讲就是，不断往左子树递归下去，然后每次都记录上一个父节点，每次把左节点置为空，把当前节点作为上一个节点的右子树。比如题目中的例子，就是从1遍历到2，把2作为1的右节点，5那一边先暂存起来。从2遍历到3，4先暂存起来，把3作为2的右节点，由于3之后为空，返回，遍历到暂存起来的4，把4作为3的右节点，如此反复。总结就是：**每次记录下左右子树，使用pre节点标记上一个父节点，左节点置为空，把左子树放到右节点位置，如此递归下去**。

代码:
```
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
    let pre = new TreeNode(0); //要new一个新的节点的原因就是递归的过程不用判断pre是不是为空
    function dfs(cur) {
        if (cur === null) {
            return null;
        }
        //提前记录，防止左右子树因为父节点修改导致丢失
        let tmpLeft = cur.left,
            tmpRight = cur.right;

        pre.right = cur;
        pre.left = null;
        pre = cur;
        dfs(tmpLeft);
        dfs(tmpRight);
    }
    dfs(root);
};
```

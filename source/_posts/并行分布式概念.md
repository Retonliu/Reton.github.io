---
title: 并行分布式概念
date: 2021-01-12 09:17
tags:
- 并行分布式
---
# 概述
## 1.分布和并行的区别：
+ 并行：是在同一台机器上的，机器是多核处理器的，可以把问题并行化进行编程
+ 分布：多台机器之间，使用网络连接的方式，构成一个整体，对外以整体提供服务

## 2.并行和并发的区别：
+ 并行：系统支持两个任务同时执行。比如边吃饭边打电话
+ 并发：系统支持两个任务同时存在，具有处理多个任务的能力，不一定要同时处理。比如吃饭吃到一半，停下来打电话，打完电话之后继续吃饭。
并行是并发的一个子集

## 3.进程和线程的区别：
+ 进程：资源分配的最小单位。系统中正在运行的应用程序就是一个进程。每个进程都有独立的代码和数据空间。
+ 线程： CPU调度的最小单位。同一类线程共享代码和数据控件，每个线程都有自己独立的运行栈和程序计数器。
操作系统可以同时运行多个进程，一个进程中可以同时执行多个线程。

## 4.并发编程中的两种观点
1. 消息传递（Message-Passing）编程。没有任何共享状态，所有同步和通信都是通过交换消息完成的。
2. 分布式内存（distributed-memory）编程。通过读取/写入共享内存块进行通信，共享内存块受信号量/锁等的保护。

## 5. 并行计算的核心
并行计算的核心是指计算机能够以任何顺序来执行的独立计算。
并行计算需要考虑以下几点：
1. 把并发工作分配到多个线程上，需要调用一些实现了线程化机制的库函数，这些函数将增加开销。 （java的thread类，run方法，线程池等方法）
2. 存储冲突或数据竞争 （多线程要访问/修改的相同变量可能需要使用信号量/锁等来保护）
3. 线程同步 （当有一个线程在对内存进行操作的时候，其他线程都不可以对这个内存地址进行操作。）

## 6. 并行编程的步骤
1. 寻找并发性 （数据/任务划分）
2. 算法结构 
3. 支持结构
4. 实现机制

## 7.基于线程化方法学
1. 分析
2. 设计与实现
3. 测试正确性
4. 性能优化


# 并行硬件和并行软件
## 1. 基于Flynn分类法的划分
Flynn分类法，是基于指令流和数据流的数量对计算机进行分类的方法。
1. 单指令单数据流（single instruction single data stream）SISD:SISD机器是一种传统的串行计算机，不支持任何并行计算。在某个时钟周期内，CPU只能处理一个数据流
2. 单指令多数据流（single instruction multiple data stream）SIMD： 对多个数据执行相同的指令从而实现在多个数据流上的操作。可以实现数据的并行性。例如同时执行1 + 1和2 + 2
- 缺点： 
    1. 全部ALUs必须执行相同指令或者等待
    2. 在经典的设计中，他们也必须同步操作
    3. ALUs没有指令存储。
    4. 适用于大型数据并行问题上，处理其他并行 问题并不优秀
- SIMD运用的领域： 
    1. 向量处理系统。可以对不同的数据并行执行相同的操作
    2. （图像处理）GPUS的着色函数的功能是隐式并行的，他们可以被应用到图形流的多个元素，GPU可以使用SIMD并行来优化算法，*不是纯粹的SIMD系统*。

3. 多指令流单数据流（multiple instruction single data stream）MISD： 比较少见，这种冗余多用于容错系统。
4. 多指令多数据流（multiple instruction multiple data stream）MIMD： 类似于多个SISD系统，常见的例子是多处理器计算机。

## 2. MIMD的进一步划分
1. MIMD的基本架构
![](1.png)
2. MIMD的分类
    1. 共享内存 
    ![](2.png)  
>    定义：
    一组自治的处理器通过互联网络与内存系统
    相连接，每个处理器能访问每个内存区域
    每个处理器都可以访问每个存储单元
    处理器通过访问共享的数据结构来隐式通信  

    2. UMA多核系统
    ![](3.png)  
>   每个核访问内存中的任何一个区域的时间相同  

    3. 分布式内存
    ![](4.png)
>   集群
        商品化系统组成
        通过商品化网络互连  
        节点 通过网络互联的独立计算单元


## 3.度量
>   Tparallel是并行运行时间  
    Tserial是串行运行时间   
    p是处理器的核心数目  
    S是加速比
公式： 
1. 加速比
```math
T_{parallel} = T_{serial} /p
```

```math
S=T_{serial} / T_{parallel}
```

2. 效率

```math
E=S/p={(T_{serial} / T_{parallel})}/p

```


3. 并行开销
```math
T_{parallel}=T_{serial}/p+T_{overhead}

```


# 寻找并发性设计空间
![](step1.png)
## 1. 并行编程的第一个步骤寻找并发性的进一步划分：
1. 分解： 任务分解和数据分解
2. 依赖分析： 任务分组，任务排序，数据共存
3. 设计评估

## 2. 任务分解
计算被分解为一组独立的任务，多个线程可以用任意顺序执行这些任务  **对计算密集的代码分解，由串行变为并行**

例子. 以园艺工作举例，任务分解会建议园丁按工作本身的属性分配任务：如果两个园丁到达一个客户家，一个修剪草坪，另一个铲除杂草。修剪草坪和铲除杂草是两个被分开的功能
## 3. 数据分解
适合问题中计算密集部分是围绕着一个大型数据结构的管理而组织的，相似的操作应用于数据结构的不同部分，这样可以相对独立的操作数据结构中的不同部分
**核心是数据块的形状和数据的交互方法**
应用程序需要处理一个大型数据集，并且可以对数据集中的每个元素进行独计算  
例子. 如果园丁应用数据分解来分解他们的任务，他们两个会同时修剪一半的草坪，然后两个人分别铲除一半的杂草

# 算法结构
![](step2.png)
- 评价
  1. 效率
  2. 简单性
  3. 可移植性
  4. 可扩展性
- 注意
  1. 效率与可移植性冲突
  2. 效率与简单性冲突
- 算法结构决策树
![](5.png)

1. 任务并行模式
定义：把问题分解为一个能够并发执行的任务集合,高效的挖掘这种并发性
任务并行的三个元素：
    1. 任务和他们的定义方式
    2. 任务间的依赖性
    3. 调度（任务怎样分配到UE）
例子. 类似于任务分解，园丁。早起的时候，一边刷牙，一边烧水。 
任务规划的要求：
        1. 任务的数据至少与UE的数目一样多，越 多越好，确保调度时有很大灵活性
        2. 与各个任务相关联的计算量必须足够多， 以此来抵消与任务管理和处理任何依赖 性相关的开销（粒度）(说简单点就是如果计算量不够大，反而线程之间的开销影响了程序的效率)
2. 分治策略：
问题被划分为许多较小的子问题，独立求解每一个子问题，并将所有的子问题解决方案合并为整个问题的解决方案，而求解整个问题
+ 特点：任务的递归安排
3. 几何分解模式：
围绕着一个已经分解为多个同时可更新的“块”的数据结构的算法模式
类似于数据分解
4. 流水线模式：
CPU指令流水
5. 基于事件的协作模式：
一些问题可以非常自然的表示为一个关于半独立实体的集合，这些半独立实体以一种不规则的方式交互

# 支持结构
![](step3.png)
## 1. 程序结构
1. SPMD（单程序多数据）
+ 在SPMD程序中，所有UE并行执行同一个程序（单程序），但每个UE都拥有自己的私有数据集（多数据）
2. 主从模式
- 定义：主进程为从进程建立一个工作池和一个任务包。所有从进程并发执行，每个从进程迭代的从任务包中移除一个任务并处理它，直到所有任务都处理完毕或到达某些终止条件为止。
- 实现方法：
    （平时实验使用的方法）
    1. 主线程中new新的子线程
    2. 使用线程池
3. 派生/聚合
一个主UE派生出多个子UE，这些子UE并行完成全部工作的某一部分。通常派生UE处于等待状态，指导所有子UE完成任务和执行聚合操作。**和主从模式的区别在于：派生聚合下，当前代的子任务无需完全做完才开始迭代下一代，根据子任务的完成进度可以不断派生。主从模式则一轮结束**
## 2. 数据结构模式
> 1. 共享数据
定义抽象数据类型，实现一种合理的并发控制协议，一次执行一个操作。简单地说就是实现了原子性和可见性的变量。
*例如共享数据库*
> 2. 共享队列
使用“线程安全”实现，即使并发执行的多个UE共同使用时，该实现也能保证正确。
RocketMQ，生产者消费者模型实验
> 3. 分布式数组
一维或多维数组，被划分为多个子数组，并在进程或线程间进行分配

# 机制设计空间
![](step4.png)
1. UE管理
创建、销毁和管理并行计算中使用的进程与线程
2. 同步
对不同UE中的事件强制约定某种顺序，确保当UE集合访问共享资源时，不论如何调度UE，程序都能正确执行
3. 通信
在UE之间交换信息
    1. 消息传递
        **消息传输是双边的**(socket)
    2. 集合通信
    两个以上UE参与通信事件时，该事件称为集合通信操作:
    - 广播：发送单条消息给所有UE
    - 栅栏：程序中的同步点，所有UE都必须到达该点，然后才能继续向后执行
    - 归约：获得一个对象集合，每个对象映射到一个UE，操作把它们组合为位于一个UE的单个对象，或组合它们并将结果广播到每个UE上
    3. 其他通信构造

# 实验相关
## 1. 生命游戏
1. 数据划分
以尽量小的交换面积来划分。以2块为例子。
对两个块并行的根据上一代计算出下一代的情况，放在新数组里面。两个子线程都计算完毕之后，合并起来就是一个新的数组。
**边界的特殊处理，由于划分的两个块边界的更新需要用到另一个块的数据，以左边块为例子，左边块的最右边一列更新的时候，需要用到右边块最左边的一列。所以其实在划分的时候，是划分给左边块的范围加上右边块的最左边一列，这样就可以更新左边块的所有列。当更新完之后，右边块也更新完了，这个时候，左边块从右边快那边获取多余的那一列的最新状态即交换数据。然后继续下一轮更新**
2. 任务划分
对于每一个细胞的状态需要更新的时候，需要判断多个条件才能是否存活，所以可以把每一个条件的判断作为一个子线程

## 2. Pi的计算
1. 数据划分
对于泰勒展开式，按照来划分，当两个线程的时候就分母每次加4，4个线程的时候就分母每次加8。
2. 任务划分
在计算泰勒公式的当前元素的时候，要用到几个步骤，可以把这几个步骤变为多个任务。
## 3. 日志挖掘
1. 任务划分
把大文件分按照日期分为多个小文件，然后创建对应数目的子线程并行读入这几个小文件到一个统一的List当中。
**数据预处理就是在读入到list当中的过程中，按照，将每一行分割为一个字符串数组。**
## 4. 线程相关知识
![](pool.png)
![](state.png)
### 1. 是否使用线程池的对比
1. 对于生命游戏由于需要多轮进行迭代，如果不使用线程池那么需要频繁的创建销毁线程，效率很低，所以使用线程池可以对子线程循环利用。
2. 计算Pi的时候，由于使用都是那几个子线程，且子线程只需要start一次，所以不用创建线程池降低空间使用。
### 2. 线程的创建
可以使用new一个继承Thread类的子类的方法来创建子线程。
### 3. 线程的使用
子类里面实现run方法。主线程通过调用子线程的start方法来使得子线程跑起来
### 4. 线程安全访问共享变量
```
global Var
lock = new Lock()
Thread:
    while(True):
        if lock.is_alive == False:
            lock.Lock()
            #do something fo Var
            lock.unLock()
        else:
            sleep(random)
            break
T1 = Thread().start()
T2 = Thread().start()
```

## 5. 主从模式和派生聚合模式的区别
1. 主从模式，主线程创造子线程，然后子线程执行之后汇总出总的结果
2. 派生聚合模式就是多个子线程执行之后，聚合，然后再派生多个子线程进行下一次迭代，即类似于多个主从模式叠加在一起。

生命游戏就是一个派生聚合模式的例子，几个子线程（派生）不断进行迭代，然后交换（聚合）
计算Pi就是一个主从模式的例子，主线程创建了几个子线程（从），子线程计算所有结果之后汇总得出最终的pi值。

## 6. 生产者消费者模型图解
![](pc.png)
生产者： 负责生产数据的模块
消费者： 负责处理数据的模块
缓冲区： 生产者和消费者的中介。生产作者把数据放入缓冲区，消费者从缓冲区中取出数据。
## 7. 生产者消费者的实现例子——————阿里云MQ
- Topic：消息主题，一级消息类型，通过Topic对消息进行分类
- 生产者：消息标签，二级消息类型，用来进一步区分某个Topic下的消息分类
- 消费者：消息消费者，也称为消息订阅者，负责接收并消费消息。可分为两类：
    1. Push Consumer：消息由消息队列RocketMQ版推送至Consumer。（被动消费者）
    2. Pull Consumer：该类Consumer主动从消息队列RocketMQ版拉取消息。（主动消费者）
- 生产者：消息生产者，也称为消息发布者，负责生产并发送消息
- Tag：消息标签，二级消息类型，用来进一步区分某个Topic下的消息分类
- 消息（message）：消息队列中信息传递的载体
- Group: 一类Producer或Consumer，这类Producer或Consumer通常生产或消费同一类消息，且消息发布或订阅的逻辑一致
- 集群消费: 一个Group ID所标识的所有Consumer平均分摊消费消息。例如某个Topic有9条消息，一个Group ID有3个Consumer实例，那么在集群消费模式下每个实例平均分摊，只消费其中的3条消息。
- 广播消费：一个Group ID所标识的所有Consumer都会各自消费某条消息一次。例如某个Topic有9条消息，一个Group ID有3个Consumer实例，那么在广播消费模式下每个实例都会各自消费9条消息。
- 定时消息：Producer将消息发送到消息队列RocketMQ版服务端，但并不期望这条消息立马投递，而是推迟到在当前时间点之后的某一个时间投递到Consumer进行消费，该消息即定时消息。同理，延时消息也类似的意思
- 顺序消息：
    1. 全局顺序：对于指定的一个Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费
    2. 分区顺序：对于指定的一个Topic，所有消息根据Sharding Key进行区块分区。同一个分区内的消息按照严格的FIFO顺序进行发布和消费。Sharding Key是顺序消息中用来区分不同分区的关键字段，电商的订单创建，以订单ID作为Sharding Key，那么同一个订单相关的创建订单消息、订单支付消息、订单退款消息、订单物流消息都会按照发布的先后顺序来消费
- 订阅关系一致： 同一个消费者 Group ID 下所有 Consumer 实例所订阅的 Topic、Group ID、Tag 必须完全一致。

## 9. 根据生产者-消费者模型衍生出来的相关并行化解决方案
![](first.jpg)
![](second.jpg)
1. 同一个进程之间
几个类通过队列进行通信
2. 不同进程之间
消费者进程通过socket将信息传输到队列当中，生产者进程通过socket从队列当中取得数据。socket使用的都是本机地址。
3. 不同机器之间
消费者进程通过socket将信息传输到队列当中，生产者进程通过socket从队列当中取得数据。生产者和消费者socket使用的地址是队列所在的ip地址。

---
title: 三数之和
date: 2020-12-09 20:20
tags:
- 双指针
- 数组
- 算法
---

>题目地址：https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/

思路：这道题如果纯靠暴力法需要三种循环，或者是回溯法都会造成时间复杂度太高直接超时。所以采用比较快的方法，**先用一个最外层的循环，按照迭代顺序，每次选取一个数，然后在里面再寻找满足条件的另外两个数**，这个是相当于三种循环的最外层循环，然后在内部，通过将里面两层循环简化为双指针的方式来使得时间复杂度降低，但是要使得问题可以使用双指针来解决问题还需要做一些准备，**需要使得数组可以满足左右指针可以按照各种条件来移动**，所以可以将数组进行排序，每当遇到里面的数相加之后不满足需要条件的时候，如果是因为太小，则往右移动左指针，因为排序之后往右移动就是变大；如果是因为太大，就往做移动右指针，因为排序之后往左移动就是变小。同时这里要注意一下可能会出现重复的情况。**这里的思路是把排序后的数组，按照迭代顺序，每次选取一个数字，然后使用双指针找到另外的两个数。排序后相同的数字是相邻的，所以去重非常简单，通过判断前面一个数字是不是跟当前相同，如果是则向下移动，在最外面的循环时使用continue，在双指针的循环过程当中时使用left++和right--，因为对于同一个最外层固定的nums[i]，也有可能有别的组合。不能直接退出双指针循环。**

代码:
```
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
    let res = [];
    const len = nums.length;

    if (len < 3) {
        return res;
    }

    nums.sort((a, b) => a - b);
    for (let i = 0; i < len; i++) {
        if (nums[i] > 0) {
            break;
        }
        if (i > 0 && nums[i] === nums[i-1]) {
            continue; // 去重
        }
        let left = i + 1, right = len - 1;
        const tmp = -nums[i];
        while (left < right) { //转换为双指针问题
            const sum = nums[left] + nums[right];
            if (sum === tmp) {
                res.push([nums[i], nums[left], nums[right]]);
                while (left < right && nums[left] == nums[left+1]) left++; // 去重
                while (left < right && nums[right] == nums[right-1]) right--; // 去重
                left++;
                right--;
            } else if (sum < tmp) {
                left++;
            } else {
                right--;
            }
        }
    }
    return res;
};
```

